package com.flaviofaria.catalog.gradle.codegen.writer

import com.flaviofaria.catalog.gradle.codegen.ResourceEntry
import com.flaviofaria.catalog.gradle.codegen.toCamelCase
import com.squareup.kotlinpoet.*
import java.io.File

@OptIn(ExperimentalKotlinPoetApi::class)
class WithArgsCatalogWriter(
  private val packageName: String,
  private val asComposeExtensions: Boolean,
  private val asPlurals: Boolean,
) : CatalogWriter<ResourceEntry.WithArgs> {

  private val receiverClass: ClassName
  private val contextClass = ClassName("android.content", "Context")
  private val fragmentClass = ClassName("androidx.fragment.app", "Fragment")
  private val rClass = ClassName(packageName, "R")
  private val composableClass = ClassName("androidx.compose.runtime", "Composable")
  private val optInClass = ClassName("kotlin", "OptIn")
  private val experimentalComposeUiApiClass = ClassName("androidx.compose.ui", "ExperimentalComposeUiApi")
  private val readOnlyComposableClass = ClassName("androidx.compose.runtime", "ReadOnlyComposable")
  private val stringResourceMember = MemberName("androidx.compose.ui.res", "stringResource")
  private val pluralResourceMember = MemberName("androidx.compose.ui.res", "pluralStringResource")

  private val fileName: String
  private val resourceGroup: String

  init {
    if (asPlurals) {
      fileName = "Plurals"
      resourceGroup = "plurals"
      receiverClass = ClassName("com.flaviofaria.catalog.runtime", "Plurals")
    } else {
      fileName = "Strings"
      resourceGroup = "string"
      receiverClass = ClassName("com.flaviofaria.catalog.runtime", "Strings")
    }
  }

  override fun write(
    resources: Iterable<ResourceEntry.WithArgs>,
    sourceSetName: String,
    codegenDestination: File,
  ) {
    val file = FileSpec.builder(packageName, fileName)
      .addFileHeaders(sourceSetName)
      .apply {
        resources.forEach { resource ->
          addResourceProperty(resource)
          addResourceFunction(resource, contextClass)
          addResourceFunction(resource, fragmentClass)
        }
      }.build()
    file.writeTo(codegenDestination)
  }

  private fun FileSpec.Builder.addFileHeaders(sourceSetName: String): FileSpec.Builder {
    val capitalizedSourceSetName = sourceSetName.replaceFirstChar {
      it.titlecase()
    }
    return addFileComment(
      """Auto-generated by Catalog. DO NOT EDIT.
      |https://github.com/flavioarfaria/Catalog""".trimMargin(),
    ).addAnnotation(
      AnnotationSpec.builder(JvmName::class)
        .addMember("%S", "$fileName$capitalizedSourceSetName")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    ).addAnnotation(
      AnnotationSpec.builder(Suppress::class)
        .addMember("%S", "NOTHING_TO_INLINE")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    )
  }

  private fun FileSpec.Builder.addResourceProperty(resource: ResourceEntry.WithArgs) {
    addProperty(
      PropertySpec.builder(resource.name.toCamelCase(), Int::class)
        .apply { resource.docs?.let(::addKdoc) }
        .receiver(receiverClass)
        .getter(
          FunSpec.getterBuilder()
            .addModifiers(KModifier.INLINE)
            .addStatement("return %T.$resourceGroup.%L", rClass, resource.name)
            .build()
        )
        .build()
    )
  }

  private fun FileSpec.Builder.addResourceFunction(
    resource: ResourceEntry.WithArgs,
    contextReceiver: TypeName,
  ) {
    val sortedArgs = resource.args.sortedBy { it.position }
    val returnType = if (sortedArgs.isEmpty()) CharSequence::class else String::class
    val statementArgs = mutableListOf<Any>()
    val methodName: String
    when {
      asComposeExtensions -> {
        statementArgs += if (asPlurals) pluralResourceMember else stringResourceMember
        methodName = "%M"
      }
      asPlurals -> {
        methodName = "resources.getQuantityString"
      }
      sortedArgs.isEmpty() -> {
        methodName = "getText"
      }
      else -> {
        methodName = "getString"
      }
    }
    val quantityParamName = "quantity"
    statementArgs.apply {
      add(rClass)
      add(resource.name)
      if (asPlurals) {
        add(quantityParamName)
      }
      addAll(resource.args.map { "arg${it.position}" })
    }

    val functionCallParams = mutableListOf("%T.$resourceGroup.%L").apply {
      if (asPlurals) {
        add("%L")
      }
      addAll(resource.args.map { "%L" })
    }

    val statementFormat = "return $methodName(${functionCallParams.joinToString()})"
    addFunction(
      FunSpec.builder(resource.name.toCamelCase())
        .apply { resource.docs?.let(::addKdoc) }
        .apply {
          if (asComposeExtensions) {
            if (asPlurals) {
              addAnnotation(
                AnnotationSpec.builder(optInClass)
                  .addMember("%T::class", experimentalComposeUiApiClass)
                  .build(),
              )
            }
            addAnnotation(composableClass)
            addAnnotation(readOnlyComposableClass)
          }
        }
        .addModifiers(KModifier.INLINE)
        .contextReceivers(contextReceiver)
        .receiver(receiverClass)
        .apply {
          if (asPlurals) {
            addParameter(name = quantityParamName, type = Int::class)
          }
          sortedArgs.forEach { parameter ->
            addParameter(
              name = "arg${parameter.position}",
              type = when (parameter.type) {
                'd', 'i' -> Int::class
                'u', 'x', 'o' -> UInt::class
                'f', 'e', 'g', 'a' -> Double::class
                's' -> String::class
                'c' -> Char::class
                else -> error(
                  """Unexpected argument type "${parameter.type}" for string
                    | resource "$name" in file "${resource.file}"""".trimMargin(),
                )
              }
            )
          }
        }
        .returns(returnType)
        .addStatement(statementFormat, *statementArgs.toTypedArray())
        .build()
    )
  }
}
