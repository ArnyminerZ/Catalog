package com.flaviofaria.catalog.gradle.codegen.writer

import com.flaviofaria.catalog.gradle.codegen.ResourceEntry
import com.flaviofaria.catalog.gradle.codegen.toCamelCase
import com.squareup.kotlinpoet.*
import java.io.File

@OptIn(ExperimentalKotlinPoetApi::class)
class StringCatalogWriter(
  private val packageName: String,
  private val composeExtensions: Boolean,
) : CatalogWriter<ResourceEntry.String> {

  private val contextClass = ClassName("android.content", "Context")
  private val fragmentClass = ClassName("androidx.fragment.app", "Fragment")
  private val stringsClass = ClassName("com.flaviofaria.catalog.runtime", "Strings")
  private val rClass = ClassName(packageName, "R")
  private val composableClass = ClassName("androidx.compose.runtime", "Composable")
  private val readOnlyComposableClass = ClassName("androidx.compose.runtime", "ReadOnlyComposable")
  private val stringResourceMember = MemberName("androidx.compose.ui.res", "stringResource")

  override fun write(
    resources: Iterable<ResourceEntry.String>,
    sourceSetName: String,
    codegenDestination: File,
  ) {
    val file = FileSpec.builder(packageName, "Strings")
      .addFileHeaders(sourceSetName)
      .apply {
        resources.forEach { resource ->
          addResourceProperty(resource)
          addResourceFunction(resource, contextClass)
          addResourceFunction(resource, fragmentClass)
        }
      }.build()
    file.writeTo(codegenDestination)
  }

  private fun FileSpec.Builder.addFileHeaders(sourceSetName: String): FileSpec.Builder {
    val capitalizedSourceSetName = sourceSetName.replaceFirstChar {
      it.titlecase()
    }
    return addFileComment(
      """Auto-generated by Catalog. DO NOT EDIT.
      |https://github.com/flavioarfaria/Catalog""".trimMargin(),
    ).addAnnotation(
      AnnotationSpec.builder(JvmName::class)
        .addMember("%S", "Strings$capitalizedSourceSetName")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    ).addAnnotation(
      AnnotationSpec.builder(Suppress::class)
        .addMember("%S", "NOTHING_TO_INLINE")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    )
  }

  private fun FileSpec.Builder.addResourceProperty(resource: ResourceEntry.String) {
    addProperty(
      PropertySpec.builder(resource.name.toCamelCase(), Int::class)
        .apply { resource.docs?.let(::addKdoc) }
        .receiver(stringsClass)
        .getter(
          FunSpec.getterBuilder()
            .addModifiers(KModifier.INLINE)
            .addStatement("return %T.string.%L", rClass, resource.name)
            .build()
        )
        .build()
    )
  }

  private fun FileSpec.Builder.addResourceFunction(
    resource: ResourceEntry.String,
    contextReceiver: TypeName,
  ) {
    val sortedArgs = resource.args.sortedBy { it.position }
    val returnType = if (sortedArgs.isEmpty()) CharSequence::class else String::class
    val statementArgs = mutableListOf<Any>()
    val methodName: String
    when {
      composeExtensions -> {
        statementArgs += stringResourceMember
        methodName = "%M"
      }
      sortedArgs.isEmpty() -> {
        methodName = "getText"
      }
      else -> {
        methodName = "getString"
      }
    }
    statementArgs.apply {
      add(rClass)
      add(resource.name)
      addAll(resource.args.map { "arg${it.position}" })
    }

    val functionCallParams = listOf("%T.string.%L") + resource.args.map { "%L" }
    val statementFormat = "return $methodName(${functionCallParams.joinToString()})"
    addFunction(
      FunSpec.builder(resource.name.toCamelCase())
        .apply { resource.docs?.let(::addKdoc) }
        .apply {
          if (composeExtensions) {
            addAnnotation(composableClass)
            addAnnotation(readOnlyComposableClass)
          }
        }
        .addModifiers(KModifier.INLINE)
        .contextReceivers(contextReceiver)
        .receiver(stringsClass)
        .apply {
          sortedArgs.forEach { parameter ->
            addParameter(
              name = "arg${parameter.position}",
              type = when (parameter.type) {
                'd', 'i' -> Int::class
                'u', 'x', 'o' -> UInt::class
                'f', 'e', 'g', 'a' -> Double::class
                's' -> String::class
                'c' -> Char::class
                else -> error(
                  """Unexpected argument type "${parameter.type}" for string
                    | resource "$name" in file "${resource.file}"""".trimMargin(),
                )
              }
            )
          }
        }
        .returns(returnType)
        .addStatement(statementFormat, *statementArgs.toTypedArray())
        .build()
    )
  }
}
